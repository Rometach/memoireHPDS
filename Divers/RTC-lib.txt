La RTC-library est la bibliothèque développée par Karlheinz Essl pour MAX/MSP. Il utilise comme support de tous ses programmes - il en recense 56, parmi lesquels la ////////////Lexicon-Sonate, son instrument-logiciel ///////////m@ze°2, et certaines de ses compositions et //////////////work-in-progress majeurs comme les ///////////Sequitur ou /////////////////fLOW. Il la distribue sous la licence ????????????????. Elle est principalement constituée d'/////////////abstractions, c'est-à-dire de ce qu'on appelerait des fonctions dans un langage plus classique : des sous-programmes avec des entrées et des sorties, qui peuvent ensuite être utilisés comme des « briques » dans d'autres programmes.

[Ici, pour que cette description permette à n'importe qui de se faire une bonne idée de ce qu'est la RTC-library, il faudrait expliquer le fonctionnement général de MAX. Même si vous ne vous y êtes jamais essayé, ce doit être assez clair pour vous, car MAX ressemble à de nombreux autres environnements de MAO. C'est un langage de type fonctionnel, basé sur une interface graphique où les objets (données, fonctions, tests...) sont représentés par des « patches » dont les entrées et les sorties sont reliés par des « câbles ». Certains de ces objets ont de plus été conçus avec une interface visuelle facilement manipulable : clavier MIDI, volume, etc.]

La RTC-library est divisée en huit rubriques, qu'illustre en outre un tutoriel. Les trois premières rubriques (//////////Toolbox, //////////////Chance et ////////////////Lists) contiennent des objets « basiques », les trois suivantes (////////////Harmony, ///////////Rhythm et ////////////Envelopes) des objets « de composition », et les deux dernières (///////////MSP et //////////Jitter) regroupent les fonctions directement liées aux sorties son et vidéo. À ce jour il y a en tout ??????????? objets, la plupart écrits par Essl, certains en collaboration avec d'autres musiciens ou programmeurs, quelques autres empruntées à d'autres bibliothèques. Dans la notice, Essl explique : « Many functions that are often useful in algorithmic composition are provided with this library - therefore the composer could concentrate rather on the composition than the programming aspects. » Il s'agit effectivement principalement de fonctions assez simples techniquement, mais conçues de manière très ergonomique.

Ainsi, on trouve de nombreuses fonctions très simples, en particulier dans la rubrique /////////Toolbox : calcul de l'inverse, de l'opposé, accumulateur... D'autres corrigent ou améliorent des fonctions pré-existantes, comme la division euclidienne (ne fonctionne à l'origine qu'avec un numérateur positif) ou l'arrondi (rendu paramétrable par Essl). 
C'est aussi le cas de la rubrique //////////////Lists, dont la plupart des fonctions proposent simplement une forme plus ergonomique de fonctions pré-existantes, parfois simplement en leur donnant un nom plus clair. C'est le cas de fonctions calculant la longueur d'une liste, l'intersection de deux listes, scindant une liste... On en trouve d'autres qui résument en une seule fonction des opérations très simples mais utiles et donc amenées à être utilisées souvent. Par exemple la fonction ////////////butfirst (respectivement //////////////butlast) cache simplement, en lui donnant une significations explicite, la scission d'une liste après son premier (respectivement avant son dernier) élément.
Enfin, les dernières fonctions avant tout pratiques que contient la RTC-library sont des conversions présentes dans chaque rubrique. Elles permettent au compositeur de manipuler les différents outils de la bibliothèque sans se soucier de leur compatibilité de type, qui peut être immédiatement gérée par ces convertisseurs. Cela va de transformations de pitch en note MIDI ou en fréquence à celles entre différentes sorties sons, ou encore à celles entre durées relatives et absolues.

Le cœur de la partie véritablement compositionnelle de la RTC-library réside à mon sens dans la rubrique //////////////Chance. En effet, bien qu'elle contienne comme ///////////////Toolbox, /////////////Lists, ////////////MSP et ///////////////Jitter des outils basiques représentant des fonctions simples, c'est la variété des générateurs aléatoires présents dans celle-ci qui rend possible la liberté de développer des algoritmes musicaux. Et c'est pour beaucoup à partir de cette variété que se construisent les fonctions des modules ///////////////Harmony, //////////////Rhythm et //////////////Envelopes. Là encore, l'ergonomie est une préoccupation importante ; tous les générateurs sont ainsi déclinés en deux fonctions, selon qu'ils fournissent leurs résultats séquentiellement, ou directement sous la forme d'une liste. Là encore, toutes les fonctions ont un code relativement simple, parfois largement fondé sur des fonctions standard de MAX, comme la génération sérielle présente nativement dans la fonction ///////////xrandom rebaptisée //////////// series. LÀ ENCORE ??????????????????????
On retrouve la plupart des générateurs aléatoires classiques : probabilité uniforme, sérialisme, chaînes de Markov, mouvement brownien. Certains sont déclinés en plusieurs variantes intégrant des paramètres supplémentaires (pondérations, interdiction de répétitions...). On remarque la présence moins commune de plusieurs générateurs reposant sur des échelles logarithmiques, mais l'absence de générateurs reposant sur des distributions de probabilité comme les lois de Gauss ou de Poisson. D'une manière générale, on trouve presque exclusivement - c'est-à-dire à l'exception du générateur de mouvement brownien, ///////////brownian - des générateurs discrets et non continus.

Si l'on se penche maintenant sur les rubriques dites « de composition », on peut y distinguer trois sortes de fonctions.
D'abord, il y a les fonctions spécifiques aux données du son concernées, qui implémentent des comportements et des outils classiques. Par exemple, la fonction ////////////neutral-harmony(n,i) génère séquentiellement des notes à partir de n par déplacement d'un intervalle i puis de son complémentaire, tandis que la /////////////metro-dev% modélise un instrumentiste humain en introduisant des approximations dans un battement parfaitement régulier, et que la fonction ////////////panning calcule la distribution stéréo des volumes pour simuler le déplacement de la source sonore. Parmi cette première sorte, toute une sous-section de ////////////////Harmony est dédiée aux manipulations dodécaphoniques usuelles.
La deuxième sorte de fonctions est une application des différents générateurs aléatoires et de certaines opérations de listes à chaque rubrique. Concrètement, ce sont à peu de choses près des convertisseurs qui transforment les résultats de ces générateurs en données représentant des hauteurs de notes (entiers d'un certain ensemble), des rythmes (//////////////bangs émis, ou entiers correspondant à des ?????????????ED), et des vélocités (entiers entre 0 et 127). Néanmoins cette description est un peu réductrice, en ce que ces fonctions considérées de l'extérieur dépassent la simple conversion de données, possèdent un véritable contenu sémantique.
Les fonctions de la troisième sorte regroupent les précédentes. Elles possèdent de nombreux paramètres d'entrée, dont la possibilité de choisir parmi les différentes méthodes aléatoires utilisables. C'est typiquement le cas du très complet ////////////super-rythm.

J'ai écrit que la plupart des algorithmes présents dans cette bibliothèque était plutôt simples ; en terme de complexité algorithmique, ils sont tous au plus linéaires (ce qui est, effectivement, une complexité faible). Cette complexité n'est en outre jamais apparente dans les algorithmes d'Essl (sous forme par exemple de boucles ou, plus évident en MAX, de récursivité), mais seulement dans les sous-procédures élémentaires qu'il appelle, plus précisément les manipulations de listes et les objets de type //////////////métronome.
[Ici aussi il aurait fallu quelques précisions sur la complexité algorithmique. J'ai supposé que vous étiez familier avec cette notion, primordiale pour tout informaticien théorique, mais j'ai l'impression qu'il y a assez peu de porosité et qu'elle est peu ou mal connue par ailleurs.]

S'il fallait décrire un « style » de programmation dans la RTC-library, je dirais que c'est une pensée avant tout fonctionnelle. Cela signifie que le paradigme avec lequel Essl approche la programmation lui fait voir les algorithmes comme des fonctions qui ///////////calculent (pensée fonctionnelle) plutôt que par exemple comme des listes d'instructions à exécuter (pensée impérative). Une illustration simple en serait la fonction /////////////remove de la rubrique /////////////Lists : pour supprimer le ////////////n-ième élément d'une liste //////////////L, Essl calcule les sous-listes //////////L1 et /////////////L2 séparées au niveau de cet élément, puis la liste ///////////////L1' comme ///////////L1 privée de son dernier élément, et enfin le résultat comme la jonction de ///////////L1' et ////////////L2. Une pensée impérative aurait plutôt fait reculer d'un rang chaque élément à partir du ///////////n+1-ième. Cela n'a rien de surprenant car c'est la manière de programmer naturellement induite par le langage MAX, et associée avec l'utilisation de listes, omniprésentes dans la RTC-library (la structure de données équivalente de la programmation impérative étant le tableau). Il est cependant intéressant de noter qu'Essl, qui a commencé à programmer avec des langages impératifs (Basic, LOGO) maîtrise parfaitement les codes du paradigme de programmation le mieux adapté dans ce contexte - malgré l'absence de récursivité, autre caractéristique essentielle de la pensée fonctionnelle. D'une manière générale, lesl algorithmes sont codés de manière directe, concise, et très claire. On peut même remarquer parfois le choix, augmentant cette concision, d'étapes //////////////hard-coded : au lieu de faire calculer une sous-fonction de manière procédurielle, l'ensemble de ses valeurs est intégralement décrit en donnée.

Enfin, quelques remarques sur les choix esthétiques sous-jacents. L'influence de l'école sérielle est très présente, ainsi que celles de Gottfried Michael Koenig et de Karlheinz Stockhausen, à qui plusieurs algorithmes font des emprunts (ils sont nommés dans les descriptions). La pensée est aussi très « pianistique » dans le sens où les notes sont décrites par d'uniques hauteur et vélocité (comme sur un piano mais pas sur un violon, où le son d'une même note peut évoluer dans le temps). Il aurait pu en être autrement compte tenu de l'intérêt qu'Essl accorde au son en général, mais cela n'a rien d'étonnant dans un langage de programmation qui privilégie la notation MIDI, et un langage musical marqué par la pensée sérielle. Rythmiquement, on peut noter un affranchissement de la notation sur partition car ce ne sont jamais des noires, croches, doubles, etc., qui sont manipulées, mais exclusivement des durées absolues. Enfin, lorsqu'il s'agit de générer les ensemble de valeurs parmi lesquelles opérer des choix aléatoires, Essl a une préférence nette pour les échelles logarithmiques - sans doute parce qu'elles permettent à la fois précision et constrates -, disponibles presque systématiquement.

En conclusion, il apparaît que les moyens techniques nécessaires à l'utilisation de cette bibliothèque en temps réel concernent avant tout l'interaction entre l'unité de calcul et les périphériques de son ou d'image. Les algorithmes utilisés par Essl sont d'une complexité très en-deça non seulement des capacités non seulement des processeurs actuels, mais aussi de leurs prédécesseurs. [Il faudrait que je creuse pour avoir une idée de ce qu'on peut exécuter en temps perçu comme réel sur les ////////////personal computers des trente dernières années, mais je soupçonne que c'était déjà le cas, ou alors presque, en 1991.] Il possède une bonne maîtrise technique, à la fois dans l'efficacité des algorithmes et dans la manière de les présenter et documenter (sans quoi l'entretien du code et son utilisation par d'autres serait beaucoup moins aisée). Mais c'est son savoir-faire de compositeur qui ressort, qui se reflète dans le choix des algorithmes plutôt que dans leur implémentation. Bien que ceux-ci soient « simples » au sens informatique, la RTC-lib est très complète car d'une part chaque algorithme de composition peut produire des résultats très divers selon la leur paramétrage, et ils sont facilement combinables, pour créer des générateurs de musique dont les modules de la ///////////Lexicon-Sonate sont d'éloquentes illustrations.


 Cher M. Wolff,

 Parfait, à tout à l'heure, donc !

 Vous en profiterez pour me dire si vous avez pu échanger avec M. Simon. Et moi j'en profite pour vous envoyer mon rapport de « mission sous le capot » après avoir passé deux jours le nez dans la RTC-lib !

 Bien à vous,

 Romain
